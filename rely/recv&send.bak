    events *ev = args;
    info *ms   = &(ev->js);
    // 记录返回值
    int returnnumber = 0;
    // 记录错误次数
    int errornumber = 0;   
   
   
   
    // 接受info
    {
        memset(ms, 0, sizeof(info));
        errornumber = 0;
    rerecv:
        if ((returnnumber = recv(cfd, ms, sizeof(info), 0)) != sizeof(info))
        {
            if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
            {
                errornumber++;
                zlog_warn(ser, "recv cfd_info failed ,rerecving~~~~~");
                if (errornumber > 3)
                {
                    zlog_error(ser, "recv cfd_info failed");
                    return;
                }
                sleep(rand() % 2);
                goto rerecv;
            }
            else
            {
                close(cfd);
                memset(ev, 0, sizeof(events));
                zlog_debug(ser, "close cfd:%d ", cfd);
                return;
            }
        }
    }

    // 发送
    {
        errornumber = 0;
    resend:
        if (sizeof(info) != (returnnumber = send(cfd, ms, sizeof(info), 0)))
        {
            if (errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)
            {
                errornumber++;
                zlog_warn(ser, "send sql failed:%s ,resending~~~~~",
                          strerror(errno));
                if (errornumber > 3)
                {
                    zlog_error(ser, "send sql failed %s ", strerror(errno));
                    return;
                }
                sleep(rand() % 2);
                goto resend;
            }
            else
            {
                close(cfd);
                memset(ev, 0, sizeof(events));
                zlog_debug(ser, "close cfd:%d ", cfd);
                return;
            }
        }
    }